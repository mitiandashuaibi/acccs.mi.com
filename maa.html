<!-- <!DOCTYPE html>
<html>
<head><meta charset="utf-8"><title>Print</title></head>
<body>
<script>
const t = new URLSearchParams(location.search).get('text') || '测试成功';
document.body.textContent = decodeURIComponent(t);
</script>
</body>
</html> -->
<!DOCTYPE html>
<html>
<head>
    <title>Get System Info</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: sans-serif; padding: 10px; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>系统信息</h1>
    <button onclick="getSystemInfo()">点击获取</button>
    <div id="result-container"></div>
    <script>
        function getSystemInfo() {
            const resultContainer = document.getElementById('result-container');
            resultContainer.innerHTML = '正在获取...';
            try {
                if (!window.PASSPORT_JSB_METHOD_INVOKER) {
                    throw new Error("JSBridge (PASSPORT_JSB_METHOD_INVOKER) not found.");
                }
                console.log("调用原生方法: getSystemInfo");
                const resultString = window.PASSPORT_JSB_METHOD_INVOKER.invokeMethod("getSystemInfo", "{}");
                console.log("原生同步返回: ", resultString);
                const data = JSON.parse(resultString);
                if (data.code === 0) {
                    const systemInfo = data.result;
                    let htmlMessage = "<table><tr><th>属性</th><th>值</th></tr>";
                    for (const key in systemInfo) {
                        htmlMessage += "<tr><td><b>" + key + "</b></td><td>" + systemInfo[key] + "</td></tr>";
                    }
                    htmlMessage += "</table>";
                    resultContainer.innerHTML = htmlMessage;
                } else {
                    throw new Error(`原生方法返回错误: code=${data.code}, message=${data.message}`);
                }
            } catch (error) {
                console.error("获取系统信息时发生错误:", error);
                resultContainer.innerHTML = '<p class="error">获取失败: ' + error.message + '</p>';
            }
        }
    </script>
</body>
    <head>
    <title>Request Cookies</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* (样式可以复用之前的) */
        body { font-family: sans-serif; padding: 10px; }
        pre { background-color: #eee; padding: 10px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; }
        .error { color: red; }
    </style>
</head>
<body>
    <h1>获取并设置登录 Cookie</h1>
    <button onclick="requestCookies()">点击请求</button>
    <div id="result-container"></div>
    <script>
        // 1. 在全局作用域下定义好回调函数，等待原生代码调用
        window.handleCookieResult = function(resultString) {
            const resultContainer = document.getElementById('result-container');
            console.log("异步回调被触发，收到数据: ", resultString);
            try {
                const data = JSON.parse(resultString);
                // 2. 检查回调返回的数据结构
                if (data.success) {
                    // 成功获取 Cookie 数据
                    const cookieInfo = data.data;
                    let html = "<h3>Cookie 获取成功!</h3>";
                    html += "<pre>" + JSON.stringify(cookieInfo, null, 2) + "</pre>";
                    resultContainer.innerHTML = html;
                } else {
                    // 后台任务执行失败
                    throw new Error("原生后台任务执行失败。");
                }
            } catch (error) {
                resultContainer.innerHTML = '<p class="error">处理回调数据时出错: ' + error.message + '</p>';
            }
        };
        function requestCookies() {
            const resultContainer = document.getElementById('result-container');
            resultContainer.innerHTML = '正在发送请求...';
            try {
                // 3. 准备调用原生方法所需的参数
                const params = {
                    // 这里的名字必须和上面定义的全局函数名一致
                    "callbackId": "handleCookieResult",
                    // Java 代码需要这个数组，内容根据你的实际需求填写
                    "serviceIdCookieDomains": [
                        { "serviceId": "passport", "cookieDomain": ".xiaomi.com" },
                        { "serviceId": "mi_eshop" } // cookieDomain 是可选的
                    ]
                };
                // 4. 调用原生方法
                const syncResult = window.PASSPORT_JSB_METHOD_INVOKER.invokeMethod(
                    "requestAndSetLoginCookies",
                    JSON.stringify(params)
                );
                // 5. 处理同步返回值 (这只是一个“已受理”的回执)
                const syncData = JSON.parse(syncResult);
                if (syncData.code === 0 && syncData.result === true) {
                    resultContainer.innerHTML = '请求已受理，正在后台获取 Cookie，请稍候...';
                } else {
                    throw new Error("请求未被原生代码受理: " + syncResult);
                }
            } catch (error) {
                console.error("调用 requestAndSetLoginCookies 时发生错误:", error);
                resultContainer.innerHTML = '<p class="error">调用失败: ' + error.message + '</p>';
            }
        }
    </script>
</body>
</html>

